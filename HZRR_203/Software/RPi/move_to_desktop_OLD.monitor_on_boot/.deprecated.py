
# print(f"_t_.WORK:{_t_}")
# print(f"_t_._did_work:{_did_work}")
# print(f"_t_._run_cnt_:{_run_cnt_}")
# print(f"func:{_func_name_clear} run_cnt:{self._e_dict[id]['run_cnt']}")
# self.dbg.m("syntax error:",funcs,cdb=1)
print("_btn_id_str:", _btn_id_str)
print("_but_text:", _but_text)
print("_call:", _call)
print("_key:", _key)
print("_retv:", _retv)
print("_btn_id:", _btn_id)
_test = st.str_to_dict(_clean)
print("str_to_dict:", _test)
# _clean = self.__inside_brackets(_clean,bo='(',bc=')')
# print("_clean2:",_clean)
# if (_gg[0] != '"' and _gg[-1] != '"'): _gg = '"' + _gg + '"'#",relief='sunken', border_width=2, size=(41,1), font=('Calibri',10),"

# _ser_bus_str    = _func_name_clear + "," + self.__inside_brackets(func, '(', ')') + "," + self.gui_terminal_ident
# _ser_work       = _ser_bus_str.split(",")
# _ser_work       = tuple(_ser_work)
# print("_ser_work:",_ser_work)
# _req, _retv, _ident = us.ser_add_work(_ser_work, cbt=True, cn2cn4=True)
# print("_req:",_req)
# print("_retv:", _retv)
# print("_ident:", _ident)
# if (id[0]=='f'):
#    _gg = self._fstr(_gg,25,4,999,split_key=">>")
# else:
#    pass
#
#
                    #if (_va_.find(',')>0):
                    #    #print("found , : ", _va_)
                    #    _arg = _va_.split(',',1)[1]
                    #    _col = _va_.split(',')[1]
                    #    _va_ = _va_.split(',')[0]
                    #    print("__va__:",_va_)
#
                    #    _te_ = ""
                    #    print("__VA__P:", _va_, " ;_te_:",_te_)
                    #    if (_va_ == "t"):
                    #        #print(f' ({_va_} == "t"):', (_va_ == "t"))
                    #        _te_ = '"[VALUES]"'
                    #    elif (_va_ == "f"):
                    #        #print(f' ({_va_} == "f"):', (_va_ == "f"))
                    #        _te_ = '"[CALL IN]"'
                    #    else:
                    #        _va_ = self.__inside_brackets(val.strip(),bo="(",bc=")" )
                    #        print("_va_ else:", _va_)
                    #        _qlen = len(_va_.split(',')) - 1
                    #        _te_ = f'"{_va_}"'
                    #        #print(f' ({_va_} == "t"): lse ({_te_})')
                    #    print("_te_:",_te_)
                    #    #if ((_va_ != 't') and (_va_ != 'f')): _te_ = _vab_
                    #    #print("_GGG1:",_te_)
                    #    _long_style = f', justification="center", relief="sunken", border_width=2, background_color="{_col}", size=(41,1), font=(\"Calibri\",10)'
                    #    _short_style= ', size=(41,1), font=(\"Calibri\",10),'
                    #    if (_va_ == 't' or _va_ == 'f'):
                    #        _gg = _te_+ _long_style
                    #        _us = _long_style
                    #    else:
                    #        _gg = _te_ + _short_style
                    #        _us = _short_style
#    #def _prep_text(self, _id, _fname, _args, _spec_call_flag = False ):
    #    _pg_class_name = "Text" if (w=="txt") else "RButton"
    #    if _spec_call_flag:
    #        # do something
    #        pass
    #    else:
    #        pass
#
    #def _prep_text_hc_funcs(self, _id, _label, _args, _spec_call_flag=False ):
    #    _hc_f_l = ('seperator(', 'headline(', )
    #    _c = False
    #    for _w in _hc_f_l:
    #        print('(_fname[:len(_w)] == _w):', (_label[:len(_w)] == _w))
    #        if (_label[:len(_w)] == _w):
    #            _c = (True, _label)
    #            break
    #    if not _c[0]: return False, False
    #    _attr_ = self.__inside_brackets(_c[1], bo='(', bc=')')
    #    return True, _attr
    # sizes
# for _w in _s:
#    if _c >= len(block_n_len):
#        _t += _w + split_key
#    else:
#        if (len(_w) < block_n_len[_c]): _t += _w + " "*(block_n_len[_c] - len(_w))
#        else:                           _t += _w[:block_n_len[_c]-2]+'..'
#        _c += 1
# pass
                #_cn4 = st.str_to_dict(st.get_parsed_key(_ident, dt=4,serbus_call=False))
#
                #print("DIR:", st._keys.__dir__())
                #if (_cn2 == False): return 0, f"str_to_dict(cn2)(mod={self.modAdr},regl={self.contr}) failed: {_cn2}"
                #if (_cn4 == False): return 0, f"str_to_dict(cn4)(mod={self.modAdr},regl={self.contr}) failed: {_cn4}"
                #self.dbg.m(f"(cn2).str_to_dict({type(_cn2)}):",_cn2,cdb=4)
                #self.dbg.m(f"(cn4).str_to_dict({type(_cn4)}):",_cn4,cdb=4)
# self.dbg.m(f'str_to_dict(st.get_parsed_key({_ident}, dt=2)', cdb=9)
# self.dbg.m(f'str_to_dict(st.get_parsed_key({_ident}, dt=4)', cdb=9)
# print("_update_string:" + '"',_update_string)
# print("_update_string:",_update_string)
# str(self._var_list[_save_to_var_clear]) + "; "
# else:
#    _gg += "---" # no display wanted
# for _nam, _val in self._var_list.items():
#    #print("id:",id,"_nam:",_nam,"val:",val,"_val:",_val)
#    _s_ = self._liveviewlistread.get(id,None)
#    _ib = self.__inside_brackets(_s_)
#    _s_ = self._liveviewlistread.get(_ib,None)
#    if _s_ == None or _s_ == object: break
#    _msk= '{'+_nam+'}'
#    print("_s_:",_s_,"_msk:",_msk)
#    _do = True
#    _donts = ('seperator(', 'headline(',)
#    for dont in _donts:
#        if (_s_[:len(dont)] == dont):
#            _do = False
#            ban = id

#    if (_do and not ban == id):
#        print("VAL:",_val)
#        _x = _s_.replace(_msk,str(_val))
#        _eme = id.split('.')[1]

#        print("_x:",_x)
#        self.form[_eme].Update(_x)

#        print("did:",_eme,"//",_x)
#           #print("_eme:",_eme )
#           #_eme = eval(_eme)
#               #_eme.update(self._liveviewlistread[id])
#        _bb = 1
#    #if _bb: break

# print(f"self._liveviewlistread[{id}]:",self._liveviewlistread[id])
# event, values = form.Layout(layout).Read()
# time.sleep(0.01)
# if not self._dict_watcher.is_alive(): self._dict_watcher.start()
# print("_id:",_id, "_attr",_attr,"_t:",type(_attr['id']))
# print("this_textNSEP:",this_text)
# print("s:",s,"_eb_:",_eb_)
#        #if _v.find(bc)>0: _eb_.append(_v.split(bc)[0]) if (rb==False) else _eb_.append( bo + _v.split(bc)[0]+ bc)
# else:
#    if (rb==False): _eb_.append(      str(str("".join(_eb_))[::-1].split(bc,1)[1])[::-1]     )
#    else:           _eb_.append( bo + str(str("".join(_eb_))[::-1].split(bc,1)[1])[::-1] + bc)
#    #print("_EB_ else:",_eb_,len(_t_))
# if (_eb_.find(',') > 0):_eb_ = _eb_.split(",")

# if (s[0] != " "): s = " " + s
# if s.find(bo)<1: return None
# return s.split(bo)[1].split(bc)[0] if (rb==False) else bo + s.split(bo)[1].split(bc)[0] + bc  # should be theinside of the bracket
# if not _in_br_list.__class__ == list:_in_br_list=_in_br_list.split(',')
##print("_in_br_list:", _in_br_list)
# for br in _in_br_list:
#    _num_from_var = f'{_lv_var[br]}'
#    val = val.replace( '{'+br+'}', _num_from_var) + " "
##print("_val:", val)
# return val
# print("a:", a)
# print("b:", udict2['func'])
# print("'self.'+udict2['id']",'self.'+udict2['id'])
# print("_testf:",_testf)


# while this_text[0] == "":  this_text.pop(0)
# while this_text[-1] == "": this_text.pop(1)

#    print("_GGG2:", _gg)
                    #        #if _func_name_clear != "seperator": _gg = '"' + _gg + '", size=(41,1), '
                    #    #elif (val.strip()[:6] == 'color('):
                    #    #    _va_ = self.__inside_brackets(val.strip(),bo="(",bc=")")
                    #    #    _va_ = "".join(_va_)
                    #    #    _gg = _va_.split(',')
                    #    #    _xe = f'self.{_gg[0]}.update({_gg[1]})'
                    #    #    _me = eval(_xe)
                    #    #    print("_me:",_me)
#
                    #else:
                        #sg.Text
                    #_long_style = f', justification="center", relief="sunken", border_width=2, background_color="{_col}", size=(41,1), font=(\"Calibri\",10)'
                    #_short_style= ', size=(41,1), font=(\"Calibri\",10),'
                    #if (_va_ == 't' or _va_ == 'f'):
                    #    _gg = _te_+ _long_style
                    #    _us = _long_style
                    #else:
                    #    _gg = _te_ + _short_style
                    #    _us = _short_style
#
                    #_gg = self._lv_get_plain_text(val,_lv_var)
                    #_gg = '"' + _gg + '"'
#
                    #print("_gg_lv_get_plain_text:",_gg)
                    #print("_gg[TXT]:",_gg)
                    #xxx = _va_              # _id, _fname, _args, _spec_call_flag = False ):
                    ##_this_text = self._prep_text(_mid, _fname,  )
                    #_this_text = self._create_dynamic(_mid, _gg, 'txt', va_ = _gg, te_ = _te_, seperator_call = False)
                    #print("_this_text[TXT]:",_this_text)
# _set_   = varname + '="' + str(_lc_)+ '"'
# print(f"_set_({_set_}):",_set_)
# exec( _set_ )
# _e = eval(varname)
# print("varname:",varname)
# print("_lc_:", _lc_)
# _this += varname+','

"""
_call_ = f'{_cf}, {_ca} ' if (w != 'txt') else f'{_cf}'
print("_call_:", _call_)
print("lb:",lb)
_this= []
_range = 4

if (w == 'txt'):
    _gg = te_.split(', ')
    _range = len(_gg)
    print("SPLIT!")

print("_range:",_range)
print("_gg:",_gg)
lb[str(_iid)] = _iid
                #event, values = form.Layout(layout).Read()
            #elif event == _w:
            #    print("send function comes here")
            #    use = ""
            #    try:
            #        #use = self._cmd_and_function_dict[_w]
            #        mod = value['cmod']
            #        #reg = value['creg']
            #        #dir = value['cdir']
            #        #dur = value['cdur']
            #        #use = use.format(mod,reg,dir,dur)
            #    except Exception as e:
            #        self.dbg.m("value['txstr']:",e, cdb = -7)
            #    #    txt = "error"
            #    #_q = ( use ,self.gui_terminal_ident)
            #    #_r = us.ser_add_work(_q, cbt=1)
            #    print("_r:")



            #layout = self.__gen_layout()
            #self.form.Close()
            #form = sg.FlexForm(self._header_line, default_element_size=(40, 1))
            #event, value = form.Layout(layout).Read()

for i in range(0,_range):
    #_ts = ((3,1), (12,1), (3,1) (3,1)) max =
    _mt = 41
    _c = 0
    _cc = False
    _ts = 0
    _ul= 0
    print("_ggppppp:",_gg)
    if (w=='txtf'):
        ll1 = len(_gg[1]) if (len(_gg[1]) <= 3) else 3
        ll2 = len(_gg[3]) if (len(_gg[3]) <= 3) else 3

        if (len(_gg[1]) > 3): _gg[1] = _gg[0][:3]
        if (len(_gg[3]) > 3): _gg[3] = _gg[2][:3]

        _l_ = [ll1, ll2]
        _cl_= _l_[1] + _l_[0]

        _ml2 = _mt - _cl_
        _t_ = ll1 if  (i==1 or i==3) else ll2
        _ul = _ml2 if (i==0) else _t_
        print(f"_txtf{_id}:",_gg)

    elif (w=='txt'):
        _tl = 0
        for  _w in _gg:
            _tl += len(str(_w))
            if (_tl >= _mt):
                _cc = True
                break
            _c += 1

        _ul = len(_gg[i])
    print("i:", _ul)
    _ts = (_ul,1)
    if _cc == True:  # last run
        _ts = (_mt - _tl, 1)
    print("_txt :", _gg)

    _q_ = lb[str(i)] if (i < 4) else _o + '_aret_' + str(i)
    locals()[_q_] = ""
    lb[str(i)] = _q_
    _bigger_than_2 = lb.get(_q_, _q_ )
    lb[str(i)] = _bigger_than_2
    _c_ = lb.get(str(i),None)
    print("_c_:",_c_)
    if _c_ == None: return False


    _txtf_s_ = _ts
    print("_gg:",_gg)
    _args_ = ""
    if type(_gg) == list:
        _args_ = "".join(str(_gg[1:]))[:]
        print("_gg:",_gg[0])
        try: _gg = ", ".join(_gg).replace('""','"') if (_cc==True and i==_c) else  ", ".join(_gg).replace('""','"')
        except Exception as e: print("_gg e:", _gg)
        print("_args:",_args_)

    print("_txtf_s1:",_gg)
    #_sty =      "relief='sunken', border_width=1, size=(17,1), font=('Calibri',10)" if (i==0) else "relief='sunken', border_width=1, size=(6,1), font=('Calibri',10)"
    #if (i == 1): _sty = f"relief='sunken', border_width=1, size={_ts[0]}, font=('Calibri',10)"
    #if (i == 2): _sty = f"relief='sunken', border_width=1, size={_ts[1]}, font=('Calibri',10)"
    #if (i == 3): _sty = f"relief='sunken', border_width=1, size={_ts[2]}, font=('Calibri',10)"
    #_sty = "" if (w == 'txt') else "relief='sunken', "
    if type(_gg) != list:
        _gg = _gg.replace('""', '"')
        _gg = _gg.split(', ')

    print("_mehgg:",_gg[i],"//",_gg[i+1:])
    _cf = str(_gg[i])
    _ca = va_


    #_ca = ", ".join(_gg[i+1:])

    if (_args_ != ""): _sty = _ca
    else:              _ca  = f"relief='sunken', border_width=1, size={_ts}, font=('Calibri',10), "
    #print("i:",i,"sty:",_sty)
    #print(f"_gg= {_gg}")

    #if (w != 'txt') : _gg[i] = '"' + str(_gg[i]) + '"'
    #else:             _gg[i] = str(_gg[i]) + '"'

    if (_cf[0] != '"') : _cf = '"' + str(_cf)
    if (_cf[-1] != '"'): _cf = str(_cf) + '"'


    #if not (_gg[i][0]=='"'):  _gg[i] = '"' + _gg[i].replace('"','')
    #if not (_gg[i][-1]=='"'): _gg[i] = _gg[i].replace('"','') + '"'
    #print(f"_ggreplace= {_cf}")
    #print(f"_styeplace= {_ca}")
    _call_ = f'{_cf}, {_ca} ' if (w != 'txt') else  f'{_cf}'
    print("_call_:",_call_)

    _varname_ = lb[str(i)]
    _v = lb[str(i)] +  f' = sg.{_x_}( {_call_} )'
    print("_v:",_v)
    try:  _exe = exec(_v)
    except: print("_lcerr_:",_v)

    print("_exe:",_exe)
    #e = eval(_varname_)
    _lc_ = locals()['lb']
    _l_ = _lc_[str(i)]
    print("_l_:",_l_)
    _this.append(_l_)
    if (_cc == True and i == _c): break
    if (_cf == '"[VALUES]"' or _cf == '"[CALL IN]"'): break
    if (seperator_call == True) : break
self.dbg.m(_this, cdb=9)
print("_this:",_this)
return _this#.split(', ')
#           args                            # tile
#           #svar             #tvar
#{_func_name_clear}({_func_args_clear})>>" + _tleft + f"s>>{_save_to_var_clear}>>({_stvc_})".strip()  # + "\\n"
"""


# ser_obj.dbg.m(f"st.got_res({_IDENTIFIER_},{cn2cn4})=",st.got_res(_IDENTIFIER_,cn2cn4))
# mydict = dict((y, x) for x, y in t) ("fucntion name",a,n,identifier)
#
#a = 0
#id_a = id(a)
#print(id_a)
#the_variable =var_id =None
#variables = {**locals(), **globals()}
#for var in variables:
#    exec('var_id=id(%s)'%var)
#    if var_id == id_a:
#        exec('the_variable=%s'%var)
#print(the_variable)
#print(id(the_variable))
#print("a:",globals())
#print("b:",*globals())
#print("c:")
#_x ={**globals()}
#print(str(_x))
#t = Conf()     # raises exception as wanted.
#t.r('','','')
#print("t:",t)
# decorating - fall back decorators
# self.w                     = class_integrity_check()(self.w                    )#(self))
# self.rs                    = class_integrity_check()(self.rs                   )#(self, section="", default="DEFAULT_ERR"))
# self.ra                    = class_integrity_check()(self.ra                   )#(self, default="DEFAULT_ERR"))
# self.buffer_ini_to_toolbox = class_integrity_check()(self.buffer_ini_to_toolbox)#(self))
# self.reload                = class_integrity_check()(self.reload               )#(self))
# self.r                     = class_integrity_check()(self.r                    )#(self, section, key, default="DEFAULT_ERR"))
# self._add_to_tbl           = class_integrity_check()(self._add_to_tbl          )#(self, _o, _v))
# exec("""def {name}():
#  print '{name}'
# """.format(name='any')) in globals()
#
# any()  # prints 'any'

# @class_integrity_checκ()()
# print("self.obj.read:",_d)
# try:
# except Exception as e:
#    raise Exception(e)
# self.textAction.value = "Erstelle Übersicht ..."
# self.dbg.m(self.pltpath)
# p = subprocess.Popen(
#    [self.pltpath, 99],
#    stdout = subprocess.PIPE,
#    shell = True
# )
# for line in iter(p.stdout.readline, b""):
#    self.textAction.value = line
# self.textAction.value = "Erstelle Übersicht ... fertig"
# time.sleep(1)
# p = subprocess.Popen(
#    [pltpath, '2', 'Z', 'F', '[]' ],
#    stdout = subprocess.PIPE,
# )
# for line in iter(p.stdout.readline, b""):
#    self.textAction.value = line
# global boxTitle, textHeadline, boxTitle, boxLogger, textLogger, buttLogOn, buttLogOff, \
#        txtLogger0, txtLogger1, txtLogger2, textLoggerB0, textLoggerB1, textLoggerB2, boxScan, \
#        buttScan, txtScan0, txtScan1, txtScan2, textScanB0, textScanB1, textScanB2, \
#        boxUeb, buttUeb, txtUeb0, txtUeb1, txtUeb2, textScanB1, textScanB2, \
#        textUebB0, textUebB1, textUebB2, boxDiagAll, buttDiagAll, txtDiagA0, \
#        txtDiagA1, txtDiagA2, textDiagAB0, textDiagAB1, textDiagAB2, boxAction, \
#        textAction0, textAction, app

# si = identifier + '_parsed' + cn + self.result_available#
# si = identifier + cn + self.result_available#
# si = identifier + '_parsed' + self.result_available#
# self.dbg.m(f"_s({si})", cdb=7)
# _res_id = _IDENTIFIER_  if (cn2cn4 != True) else _IDENTIFIER_+'_cn4' #if (cbt or logger_r or mon_r) else
# ser_obj.dbg.m(f"st.got_res({_IDENTIFIER_},{cn2cn4})=",st.got_res(_IDENTIFIER_,cn2cn4))

# cn = ""
# self.dbg.m(f".{si}", cdb=7)
# try:
# _x =
#    if (_x == None):
#        #self.dbg.m(f"_got_result({si}) = {_x}", cdb=7)
#        return False
# except Exception as e:
#    #self.dbg.m(f".{identifier} Exception:", e, cdb=-7)
#    return False
# self.dbg.m(f"_x = {_x}", cdb=11)
        #ser_obj.dbg.m("got cn2+cn4 -> deepcopy into log_obj.cn2/cn4.",cdb=2)
        #ser_obj.dbg.m("log_obj.cn2:", lg.log_obj._cn2,cdb=9) # 9 = verbose debug
        #ser_obj.dbg.m("log_obj.cn4:", lg.log_obj._cn4,cdb=9) # 9 = verbose debug

        #if (identifier.find('_') > 0):  
        #    si = identifier.split("_")[0:4]
        #    _t = ""
        #    for w in si:
        #        _t += w + "_"
        #    si = _t[:-1] + self.result_available
        #else: 

        #si = str(identifier.split("_")[0:4]) + self.result_available if (identifier.find('_')>0) else identifier + self.result_available
        #if (identifier.find('_') > 0):  
        #    si = identifier.split("_")[0:4]
        #    _t = ""
        #    for w in si:
        #        _t += w + "_"
        #    si = _t[:-1] + specific + self.result_available
        #else: 

        #print("EEE_cmd:",cmd)

        #print("EEE__r str:",_r,f'({len(_r)}<3):{(len(_r)<3)}')

        #print("EEE__r str:",_r,f'({len(_r)}<3):{(len(_r)<3)}')

        #print("EEE__r str:",_r)
        #_r = _r.split(',') if (_r.find(',')>0) else _r
        #print("EEE__r w/e:",_r,"//type:",type(_r))
#
        #if (type(_r) == list or type(_r) == tuple):
        #    if (len(_r) < 2): 
        #        _r = _r[0]
        #        print('EEE_r:(len(_r) <<<<<<<<<< 2)')
        #    else:
        #        _t = ""
        #        for kw in _r:
        #            _t += kw + ","
        #        _r = _t.strip()[0:-1]
        #        print(f'EEE_r:(len(_r) >>>>>>>>>> 2) _t = {_t}')
        #print('EEE_r:',_r)


        #_x = "[TTL HAS BEEN PASSED]" if ttl_pass != False else ""
        #self.dbg.m("__response_gathered: entering", cdb = self.spam_debug_level)
        #self.dbg.m("__response_gathered():",self.comm_rspTo if (ttl_pass == False) else f"{self.comm_rspTo} -> {_x}",cdb=self.spam_debug_level)
        #self.dbg.m("__response_gathered.comm_rsp:",self.comm_rsp,cdb=self.spam_debug_level)
        #self.comm_rsp       = ""
        #self.comm_rspTo     = ""
        #self.comm_getdone   = True
        #self.dbg.m("__response_gathered.__getrem_clear_ident try with:", self._this_response_request_by, cdb=3)
        #self.__getrem_clear_ident(self._this_response_request_by)
        #self._this_response_request_by = ""

        #_r = ""
        #for i in range(1,len(cmd)-self.comm_current_max_options): _r += str(cmd[i])+","
        #_r = _r[:-1] # remove ","

        #if not self.__comm_handle_exec_list_has_elements(): return self.comm_handle_requests(dir=0,reent=True)# no work, what am i even doing here.
        #cmd = copy.deepcopy(self.comm_req)#self.comm_req.pop(dir) # check with a copy to avoid confusion in the list..
        #try:
        #    cmd = cmd.pop(dir)
        #except Exception as e:
        #    self.dbg.m('__comm_handle_pre_check -> cmd.pop(dir):',e,cdb=-7)
        #    return self.comm_handle_requests(dir=0,reent=True)
        #
        #_response_for_ident_exists, _ret = self.__getrem_retval_exists(cmd[-1])
        #if (_response_for_ident_exists):
        #    self.dbg.m(f"comm_handle_requests(ident='{cmd[-1]}'): has output waiting in queue - waiting")
        #    list_size = len(cmd)-1
        #    if (list_size > 1):
        #        self.dbg.m(f"comm_handle_requests(list_size > 1({str(list_size)}):TRUE) calling: 'comm_handle_requests(dir=-1)'")
        #        return self.comm_handle_requests(dir=-1) # take upper one now.
        #    else:
        #        self.dbg.m(f"comm_handle_requests(list_size > 1({str(list_size)}):ELSE) calling: 'comm_handle_requests(dir=0,reent=True)'")
        #        return self.comm_handle_requests(dir=0,reent=True)# just return to rejoin the loop with hopefully more work or an empty queue.
    #def get_response(self,calling_thread_var=""): # just a check variable that not the wrong thread does steal the information
    #    # this identifies the calling thread and gives the
    #    if calling_thread_var == "": return False,("calling thread var is empty")
    #    _worked, _answertuple = self.__getrem_retval_exists(calling_thread_var)
    #    if not _worked: return False,('key does not exist')
    #    self.dbg.m("get_response:",calling_thread_var, "==",self.comm_rspTo,cdb=3)
    #    self._this_response_request_by = calling_thread_var
    #    retval = self.comm_rspTo
    #    _r = self.__getrem_retval()
    #    self.__response_gathered()
    #    self.dbg.m("get_response:",_r,cdb=2)
    #    return True,(_r)

    #def response_available(self,for_who=""):
    #    _x, _m = self.__getrem_retval_exists(for_who)
    #    self.dbg.m("response_available:",_x,"//msg:",_m,"//for:",for_who,cdb=11)
    #    if _x: return True, (_x,_m)
    #    return False, (_x,_m)

    #def __reset_output_queue(self,w):
    #    self.comm_rspListDict = []
    #    pass
    #    #del

    #def __comm_handle_output_watcher(self):
    #    pass
    #    #cheeck the output for duplicates.
    #    #if there are, remvoe all outputs and maybe restart the modul which did produce the error...
#__x = 0
#_default_cn2    =   {"SN":__x,"VM":__x,"RM":__x,"VE":__x,"RE":__x,"RS":__x,"PM":__x} # command names
#_default_cn4    =   {"ER":__x,"FX":__x,"MT":__x,"NL":__x} # command names
#__x = -2
#cn2_ser         =   {"SN":__x,"VM":__x,"RM":__x,"VE":__x,"RE":__x,"RS":__x,"PM":__x} # command names
#cn4_ser         =   {"ER":__x,"FX":__x,"MT":__x,"NL":__x} # command names
#__x = -3
#cn2_log         =   {"SN":__x,"VM":__x,"RM":__x,"VE":__x,"RE":__x,"RS":__x,"PM":__x} # command names
#cn4_log         =   {"ER":__x,"FX":__x,"MT":__x,"NL":__x} # command names
#__x = -4
#cn2_mon         =   {"SN":__x,"VM":__x,"RM":__x,"VE":__x,"RE":__x,"RS":__x,"PM":__x} # command names
#cn4_mon         =   {"ER":__x,"FX":__x,"MT":__x,"NL":__x} # command names
#__x = -5
#cn2_ter         =   {"SN":__x,"VM":__x,"RM":__x,"VE":__x,"RE":__x,"RS":__x,"PM":__x} # command names
#cn4_ter         =   {"ER":__x,"FX":__x,"MT":__x,"NL":__x} # command names

## status variables for logging
#def get_cn(m=""):
#    #print("[GET_CN]:",m)
#    global cn2_mon,cn4_mon,cn2_log,cn4_log,cn2_ser,cn4_ser,cn2,cn4
#    if (m=='m'): return (cn2_mon,cn4_mon)
#    if (m=='s'): return (cn2_ser,cn4_ser)
#    if (m=='l'): return (cn2_log,cn4_log)
#    return (cn2,cn4)
#
#def set_cn(m="m"):
#    global cn2_mon,cn4_mon,cn2_log,cn4_log,cn2_ser,cn4_ser,cn2,cn4
#    if (m=='m'):
#        cn2_mon.update(cn2_ser)
#        cn4_mon.update(cn4_ser)
#        while (cn2_mon != cn2_ser and cn4_mon != cn4_ser): pass #wait for update to finish
#        reset_cn('s')
#    if (m=='s'):
#        cn2_ser.update(cn2)
#        cn4_ser.update(cn4)
#        while (cn2_ser != cn2 and cn4_ser != cn4): pass #wait for update to finish
#        reset_cn('')
#    if (m=='l'):
#        cn2_log.update(cn2_ser)
#        cn4_log.update(cn4_ser)
#        while (cn2_log != cn2_ser and cn4_log != cn4_ser): pass #wait for update to finish
#        reset_cn('s')
#
#def reset_cn(m="m"):
#    global cn2_mon,cn4_mon,cn2_log,cn4_log,cn2_ser,cn4_ser,cn2,cn4
#    if (m=='m'):
#        cn2_mon.update(_default_cn2)
#        cn4_mon.update(_default_cn4)
#        while (cn2_mon != _default_cn2 and cn4_mon != _default_cn4): pass #wait for update to finish
#    if (m=='s'):
#        cn2_ser.update(_default_cn2)
#        cn4_ser.update(_default_cn4)
#        while (cn2_ser != _default_cn2 and cn4_ser != _default_cn4): pass #wait for update to finish
#    if (m=='l'):
#        cn2_log.update(_default_cn2)
#        cn4_log.update(_default_cn4)
#        while (cn2_log != _default_cn2 and cn4_log != _default_cn4): pass #wait for update to finish
#    if (m=='t'):
#        cn2_ter.update(_default_cn2)
#        cn4_ter.update(_default_cn4)
#        while (cn2_ter != _default_cn2 and cn4_ter != _default_cn4): pass #wait for update to finish
#    else:
#        cn2.update(_default_cn2)
#        cn4.update(_default_cn4)
#        while (cn2 != _default_cn2 and cn4 != _default_cn4): pass #wait for update to finish
#
#
#def get_cn_d():
#    global _default_cn2, _default_cn4
#    return (_default_cn2, _default_cn4)

# Parameter for each regulator
#   active, motIMin, motIMax, tMotDelay, tMotMin, tMotMax,
#   dtOpen, dtClose, dtOffset, tMotTotal, nMotLimit,
#   pFakt, iFakt, dFakt, tauTempVl, tauTempRl, tauM, m2hi, m2lo,
#   tMotPause, tMotBoost, dtMotBoost, dtMotBoostBack
    #def set_rx_cpy(self,v,who='m'):
    #    if   who == 'm': self.mon_rx_cpy = v
    #    elif who == 'l': self.log_rx_cpy = v
    #    elif who == 't': self.ter_rx_cpy = v
    #    else: pass
    #
    #def __reset_return_val(self,v='m'):
    #    if v=='m':
    #        _x = self.mon_rx_cpy
    #        self.mon_rx_cpy=""
    #        return _x
    #    elif v=='l':
    #        _x = self.log_rx_cpy
    #        self.log_rx_cpy=""
    #        return _x
    #    elif v=='t':
    #        _x = self.ter_rx_cpy
    #        self.ter_rx_cpy=""
    #        return _x
    #
    #def get_rx_cpy(self,f='m'):
    #    return self.__reset_return_val(f)



